module.exports=function(a){function b(d){if(c[d])return c[d].exports;var e=c[d]={i:d,l:!1,exports:{}};return a[d].call(e.exports,e,e.exports,b),e.l=!0,e.exports}var c={};return b.m=a,b.c=c,b.d=function(a,c,d){b.o(a,c)||Object.defineProperty(a,c,{configurable:!1,enumerable:!0,get:d})},b.n=function(a){var c=a&&a.__esModule?function(){return a['default']}:function(){return a};return b.d(c,'a',c),c},b.o=function(a,b){return Object.prototype.hasOwnProperty.call(a,b)},b.p='',b(b.s=7)}([function(a){a.exports=require('source-map-support/register')},function(a){a.exports=require('babel-runtime/core-js/object/keys')},function(a){a.exports=require('babel-runtime/helpers/asyncToGenerator')},function(a){a.exports=require('clientnode')},function(a,b,c){'use strict';function d(a){return a&&a.__esModule?a:{default:a}}b.__esModule=!0,b.Helper=void 0;var e=c(1),f=d(e),g=c(2),h=d(g),i=c(3),j=d(i),k=c(5),l=d(k);try{c(0)}catch(a){}global.fetch=l.default;class m{static ensureValidationDocumentPresence(a,b,c,d,e=!0){return(0,h.default)(function*(){const f=j.default.extendObject({_id:`_design/${b}`,language:'javascript'},c);try{const c=yield a.get(`_design/${b}`);f._rev=c._rev,yield a.put(f),e&&console.info(`${d} updated.`)}catch(b){e&&('not_found'===b.error?console.info(`${d} not available: create new one.`):console.info(`${d} couldn't be updated: "`+`${j.default.representObject(b)}" create new one.`));try{yield a.put(f),e&&console.info(`${d} installed/updated.`)}catch(a){throw new Error(`${d} couldn't be installed/updated: "`+`${j.default.representObject(a)}".`)}}})()}static determineAllowedModelRolesMapping(a){const b=a.property.name.special.allowedRole,c={},d=m.extendModels(a);for(const e in d)if(d.hasOwnProperty(e)&&d[e].hasOwnProperty(b))for(const a in c[e]=m.normalizeAllowedModelRoles(d[e][b]),c[e].properties={},d[e])d[e].hasOwnProperty(a)&&d[e][a].hasOwnProperty('allowedRoles')&&d[e][a].allowedRoles&&(c[e].properties[a]=m.normalizeAllowedModelRoles(d[e][a].allowedRoles));else c[e]={read:[],write:[],properties:{}};return c}static determineGenericIndexablePropertyNames(a,b){const c=a.property.name.special;return(0,f.default)(b).filter((d)=>b[d].index||!(b[d].hasOwnProperty('index')&&!b[d].index||a.property.name.reserved.concat(c.additional,c.allowedRole,c.attachment,c.conflict,c.constraint.execution,c.constraint.expression,c.deleted,c.deleted_conflict,c.extend,c.id,c.maximumAggregatedSize,c.minimumAggregatedSize,c.revision,c.revisions,c.revisionsInformation,c.type).includes(d)||b[d].type&&('string'==typeof b[d].type&&b[d].type.endsWith('[]')||Array.isArray(b[d].type)&&b[d].type.length&&Array.isArray(b[d].type[0])||a.entities.hasOwnProperty(b[d].type)))).concat(c.id,c.revision)}static extendModel(a,b,c='_extends'){if('_base'===a)return b[a];if(b.hasOwnProperty('_base')&&(b[a].hasOwnProperty(c)?b[a][c]=['_base'].concat(b[a][c]):b[a][c]='_base'),b[a].hasOwnProperty(c)){for(const d of[].concat(b[a][c]))b[a]=j.default.extendObject(!0,{},m.extendModel(d,b,c),b[a]);delete b[a][c]}return b[a]}static extendModels(a){const b=a.property.name.special,c={};for(const d in a.entities)if(a.entities.hasOwnProperty(d)){if(!(new RegExp(a.property.name.typeRegularExpressionPattern.public).test(d)||new RegExp(a.property.name.typeRegularExpressionPattern.private).test(d)))throw new Error('Model names have to match "'+a.property.name.typeRegularExpressionPattern.public+'" or "'+a.property.name.typeRegularExpressionPattern.private+`" for private one (given name: "${d}").`);c[d]=m.extendModel(d,a.entities,b.extend)}for(const d in c)if(c.hasOwnProperty(d))for(const e in c[d])if(c[d].hasOwnProperty(e))if(e===b.attachment)for(const b in c[d][e])c[d][e].hasOwnProperty(b)&&(c[d][e][b]=j.default.extendObject(!0,j.default.copyLimitedRecursively(a.property.defaultSpecification),c[d][e][b]));else[b.allowedRole,b.constraint.execution,b.constraint.expression,b.extend,b.maximumAggregatedSize,b.minimumAggregatedSize].includes(e)||(c[d][e]=j.default.extendObject(!0,j.default.copyLimitedRecursively(a.property.defaultSpecification),c[d][e]));return c}static normalizeAllowedModelRoles(a){if(Array.isArray(a))return{read:a,write:a};if('object'==typeof a){const b={read:[],write:[]};for(const c in b)a.hasOwnProperty(c)&&(b[c]=Array.isArray(a[c])?a[c]:[a[c]]);return b}return{read:[a],write:[a]}}}b.Helper=m,b.default=m},function(a){a.exports=require('node-fetch')},,function(a,b,c){a.exports=c(4)}]);