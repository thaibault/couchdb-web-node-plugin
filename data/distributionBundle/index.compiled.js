module.exports=function(a){function b(d){if(c[d])return c[d].exports;var e=c[d]={i:d,l:!1,exports:{}};return a[d].call(e.exports,e,e.exports,b),e.l=!0,e.exports}var c={};return b.m=a,b.c=c,b.d=function(a,c,d){b.o(a,c)||Object.defineProperty(a,c,{configurable:!1,enumerable:!0,get:d})},b.n=function(a){var c=a&&a.__esModule?function(){return a['default']}:function(){return a};return b.d(c,'a',c),c},b.o=function(a,b){return Object.prototype.hasOwnProperty.call(a,b)},b.p='',b(b.s=8)}([function(a){a.exports=require('source-map-support/register')},function(a){a.exports=require('babel-runtime/core-js/object/keys')},function(a){a.exports=require('babel-runtime/helpers/asyncToGenerator')},function(a){a.exports=require('clientnode')},function(a,b,c){'use strict';function d(a){return a&&a.__esModule?a:{default:a}}b.__esModule=!0,b.Helper=void 0;var e=c(1),f=d(e),g=c(2),h=d(g),i=c(3),j=d(i),k=c(5),l=d(k);try{c(0)}catch(a){}global.fetch=l.default;class m{static ensureValidationDocumentPresence(a,b,c,d,e=!0){return(0,h.default)(function*(){const f=j.default.extendObject({_id:`_design/${b}`,language:'javascript'},c);try{const c=yield a.get(`_design/${b}`);f._rev=c._rev,yield a.put(f),e&&console.info(`${d} updated.`)}catch(b){e&&('not_found'===b.error?console.info(`${d} not available: create new one.`):console.info(`${d} couldn't be updated: "`+`${j.default.representObject(b)}" create new one.`));try{yield a.put(f),e&&console.info(`${d} installed/updated.`)}catch(a){throw new Error(`${d} couldn't be installed/updated: "`+`${j.default.representObject(a)}".`)}}})()}static determineAllowedModelRolesMapping(a){const b=a.property.name.special.allowedRole,c={},d=m.extendModels(a);for(const e in d)if(d.hasOwnProperty(e)&&d[e].hasOwnProperty(b))for(const a in c[e]=m.normalizeAllowedModelRoles(d[e][b]),c[e].properties={},d[e])d[e].hasOwnProperty(a)&&d[e][a].hasOwnProperty('allowedRoles')&&d[e][a].allowedRoles&&(c[e].properties[a]=m.normalizeAllowedModelRoles(d[e][a].allowedRoles));else c[e]={read:[],write:[],properties:{}};return c}static determineGenericIndexablePropertyNames(a,b){const c=a.property.name.special;return(0,f.default)(b).filter((d)=>b[d].index||!(b[d].hasOwnProperty('index')&&!b[d].index||a.property.name.reserved.concat(c.additional,c.allowedRole,c.attachment,c.conflict,c.constraint.execution,c.constraint.expression,c.deleted,c.deleted_conflict,c.extend,c.id,c.maximumAggregatedSize,c.minimumAggregatedSize,c.revision,c.revisions,c.revisionsInformation,c.type).includes(d)||b[d].type&&('string'==typeof b[d].type&&b[d].type.endsWith('[]')||Array.isArray(b[d].type)&&b[d].type.length&&Array.isArray(b[d].type[0])||a.entities.hasOwnProperty(b[d].type)))).concat(c.id,c.revision)}static extendModel(a,b,c='_extends'){if('_base'===a)return b[a];if(b.hasOwnProperty('_base')&&(b[a].hasOwnProperty(c)?b[a][c]=['_base'].concat(b[a][c]):b[a][c]='_base'),b[a].hasOwnProperty(c)){for(const d of[].concat(b[a][c]))b[a]=j.default.extendObject(!0,{},m.extendModel(d,b,c),b[a]);delete b[a][c]}return b[a]}static extendModels(a){const b=a.property.name.special,c={};for(const d in a.entities)if(a.entities.hasOwnProperty(d)){if(!(new RegExp(a.property.name.typeRegularExpressionPattern.public).test(d)||new RegExp(a.property.name.typeRegularExpressionPattern.private).test(d)))throw new Error('Model names have to match "'+a.property.name.typeRegularExpressionPattern.public+'" or "'+a.property.name.typeRegularExpressionPattern.private+`" for private one (given name: "${d}").`);c[d]=m.extendModel(d,a.entities,b.extend)}for(const d in c)if(c.hasOwnProperty(d))for(const e in c[d])if(c[d].hasOwnProperty(e))if(e===b.attachment)for(const b in c[d][e])c[d][e].hasOwnProperty(b)&&(c[d][e][b]=j.default.extendObject(!0,j.default.copyLimitedRecursively(a.property.defaultSpecification),c[d][e][b]));else[b.allowedRole,b.constraint.execution,b.constraint.expression,b.extend,b.maximumAggregatedSize,b.minimumAggregatedSize].includes(e)||(c[d][e]=j.default.extendObject(!0,j.default.copyLimitedRecursively(a.property.defaultSpecification),c[d][e]));return c}static normalizeAllowedModelRoles(a){if(Array.isArray(a))return{read:a,write:a};if('object'==typeof a){const b={read:[],write:[]};for(const c in b)a.hasOwnProperty(c)&&(b[c]=Array.isArray(a[c])?a[c]:[a[c]]);return b}return{read:[a],write:[a]}}}b.Helper=m,b.default=m},function(a){a.exports=require('node-fetch')},function(a){a.exports=require('babel-runtime/core-js/json/stringify')},,function(a,b,c){a.exports=c(9)},function(a,b,c){'use strict';function d(a){return a&&a.__esModule?a:{default:a}}b.__esModule=!0,b.Database=void 0;var e=c(6),f=d(e),g=c(10),h=d(g),i=c(2),j=d(i),k=c(11),l=c(3),m=d(l),n=c(12),o=d(n),p=c(13),q=d(p),r=c(14),s=d(r),t=c(15),u=d(t),v=c(16),w=d(v),x=c(4),y=d(x);try{c(0)}catch(a){}class z{static loadService(a,b,c){return(0,j.default)(function*(){let a=null;if(b.database.server.hasOwnProperty('binaryFilePath')&&(b.database.server.process=(0,k.spawn)(b.database.server.binaryFilePath,['--config',c.database.configurationFilePath,'--dir',q.default.resolve(c.database.path),'--host',c.database['httpd/host'],'--port',`${c.database.port}`],{cwd:eval('process').cwd(),env:eval('process').env,shell:!0,stdio:'inherit'}),a=new h.default(function(a,c){for(const d of m.default.closeEventNames)b.database.server.process.on(d,m.default.getProcessCloseHandler(a,c,{reason:d,process:b.database.server.process}))}),yield m.default.checkReachability(m.default.stringFormat(c.database.url,''),!0)),b.database.hasOwnProperty('connection'))return{promise:a};if(c.database.ensureAdminPresence){const a=new b.database.connector(`${m.default.stringFormat(c.database.url,'')}/`+`_users`,c.database.connector);try{yield a.allDocs(),console.info('No admin user available. Automatically creating admin '+`user "${c.database.user.name}".`),yield fetch(`${m.default.stringFormat(c.database.url,'')}/`+`_config/admins/${c.database.user.name}`,{method:'PUT',body:`"${c.database.user.password}"`})}catch(a){if(a.hasOwnProperty('name')&&'unauthorized'===a.name){const a=new b.database.connector(m.default.stringFormat(c.database.url,`${c.database.user.name}:`+`${c.database.user.password}@`)+'/_users',c.database.connector);try{yield a.allDocs()}catch(a){console.error(`Can't login as existing admin user "`+`${c.database.user.name}": "`+`${m.default.representObject(a)}".`)}finally{a.close()}}else console.error(`Can't create new admin user "`+`${c.database.user.name}": "`+`${m.default.representObject(a)}".`)}finally{a.close()}}if(c.database.ensureUserPresence)for(const a of['admins','members'])for(const d of c.database.security[a].names){const e=new b.database.connector(m.default.stringFormat(c.database.url,`${c.database.user.name}:`+`${c.database.user.password}@`)+'/_users',c.database.connector);try{yield e.get(`org.couchdb.user:${d}`)}catch(b){if(b.hasOwnProperty('error')&&'not_found'===b.error)try{yield e.put({[c.database.model.property.name.special.id]:`org.couchdb.user:${d}`,name:d,password:d,roles:[].concat(c.database.security[a].roles.includes(`${d}s`)?`${d}s`:[]),type:'user'})}catch(a){throw new Error(`Couldn't create missing user "${d}":`+` ${m.default.representObject(a)}`)}else throw new Error(`Couldn't check for presence of user "`+`${d}": ${m.default.representObject(b)}`)}finally{e.close()}}if(c.database.model.updateConfiguration)for(const a in c.database)if(c.database.hasOwnProperty(a)&&a.includes('/'))try{yield fetch(m.default.stringFormat(c.database.url,`${c.database.user.name}:`+`${c.database.user.password}@`)+`/_config/${a}`,{method:'PUT',body:'"'+`${c.database[a]}"`})}catch(b){console.error(`Configuration "${a}" couldn't `+'be applied to "'+`${c.database[a]}": `+m.default.representObject(b))}b.database.connection=new b.database.connector(m.default.stringFormat(c.database.url,`${c.database.user.name}:`+`${c.database.user.password}@`)+`/${c.name}`,c.database.connector),b.database.connection.setMaxListeners(Infinity);const d=c.database.model.property.name.special.id,e=c.database.model.property.name.special.revision,g=c.database.model.property.name.special.type;for(const a of['post','put']){const f=b.database.connection[a].bind(b.database.connection);b.database.connection[a]=(()=>{var a=(0,j.default)(function*(a,...b){try{return yield f(a,...b)}catch(b){if(d in a&&c.database.ignoreNoChangeError&&'name'in b&&'forbidden'===b.name&&'message'in b&&b.message.startsWith('NoChange:')){const b={id:a[d],ok:!0};try{b.rev=e in a&&!['latest','upsert'].includes(a[e])?a[e]:(yield this.get(b.id))[e]}catch(a){throw a}return b}throw b}});return function(){return a.apply(this,arguments)}})()}if(c.database.ensureSecuritySettingsPresence)try{yield fetch(m.default.stringFormat(c.database.url,`${c.database.user.name}:`+`${c.database.user.password}@`)+`/${c.name}/_security`,{method:'PUT',headers:{"Content-Type":'application/json'},body:(0,f.default)(c.database.security)})}catch(a){console.error(`Security object couldn't be applied.: `+m.default.representObject(a))}const i=m.default.copyLimitedRecursively(c.database.model);delete i.property.defaultSpecification,delete i.entities;const l=y.default.extendModels(c.database.model);if(c.database.model.updateValidation){const a=yield new h.default(function(a,b){return o.default.readFile(eval('require.resolve')('./databaseHelper.compiled'),{encoding:c.encoding,flag:'r'},function(c,d){return c?b(c):a(d)})}),e='function(...parameter) {\n'+`    return require('helper').default.validateDocumentUpdate`+'(...parameter.concat(['+(0,f.default)(l)+', '+(0,f.default)(i)+']))\n}';try{new Function(`return ${e}`)}catch(a){throw new Error(`Generated validation code "${e}" doesn't `+`compile: ${m.default.representObject(a)}`)}c.debug&&console.info('Specification \n\n"'+m.default.representObject(c.database.model)+`"\n\nhas generated validation code: \n\n"`+`${e}".`),yield y.default.ensureValidationDocumentPresence(b.database.connection,'validation',{helper:a,validate_doc_update:e},'Model specification');const j='function(...parameter) {\n'+`    return require('helper').default.authenticate(`+'...parameter.concat(['+(0,f.default)(y.default.determineAllowedModelRolesMapping(c.database.model))+`, '${d}', '${g}']))\n`+'}';try{new Function(`return ${j}`)}catch(a){throw new Error(`Generated authentication code "${j}" `+`doesn't compile: ${m.default.representObject(a)}`)}for(const d in c.debug&&console.info(`Authentication code "${j}" generated.`),yield y.default.ensureValidationDocumentPresence(b.database.connection,'authentication',{helper:a,validate_doc_update:j},'Authentication logic'),l)if(l.hasOwnProperty(d))for(const a in l[d])if(l[d].hasOwnProperty(a))if([i.property.name.special.constraint.execution,i.property.name.special.constraint.expression].includes(a)){for(const b of l[d][a])if(b.hasOwnProperty('description')&&b.description)try{new Function('return '+b.description)}catch(a){throw new Error(`Specified constraint `+`description "`+`${b.description}" `+`for model "${d}" `+`doesn't compile: "`+m.default.representObject(a)+'".')}}else for(const b of['conflictingConstraintExpression','conflictingConstraintExecution','constraintExpression','constraintExecution'])if(l[d][a][b]&&l[d][a][b].hasOwnProperty('description'))try{new Function(l[d][a][b].description)}catch(c){throw new Error(`Specified constraint `+`description "`+l[d][a][b].description+`" for model "${d}" `+`in property "${a}" as "`+`${b}" doesn't compile: "`+m.default.representObject(c)+'".')}}if(c.database.model.autoMigrationPath){if(yield m.default.isDirectory(q.default.resolve(c.database.model.autoMigrationPath)))for(const a of yield m.default.walkDirectoryRecursively(q.default.resolve(c.database.model.autoMigrationPath))){const e=q.default.extname(a.name),f=q.default.basename(a.name,e);if(c.database.model.entities.hasOwnProperty(f)&&'.json'===e)for(const e of JSON.parse((yield new h.default(function(b,d){return o.default.readFile(a.path,{encoding:c.encoding,flag:'r'},function(a,c){return a?d(a):b(c)})})))){e[g]=f;try{yield b.database.connection.put(e)}catch(a){throw new Error(`Migrating document "`+`${e[d]}" of type "`+`${e[g]}" has failed: `+m.default.representObject(a))}console.info(`Including document "`+`${e[d]}" of type "`+`${e[g]}" was successful.`)}}for(const a of(yield b.database.connection.allDocs({include_docs:!0})).rows)if(!('string'==typeof a.id&&a.id.startsWith('_design/'))){const e=a.doc,f=m.default.copyLimitedRecursively(e);f[c.database.model.property.name.special.strategy]='migrate';try{w.default.validateDocumentUpdate(m.default.copyLimitedRecursively(f),m.default.copyLimitedRecursively(e),{db:c.name,name:c.database.user.name,roles:['_admin']},m.default.copyLimitedRecursively(c.database.security),l,i)}catch(a){if('forbidden'in a){a.forbidden.startsWith('NoChange:')||console.warn(`Document "`+`${m.default.representObject(e)}" `+`doesn't satisfy its schema (and can not`+` be migrated automatically): `+m.default.representObject(a));continue}else throw a}try{yield b.database.connection.put(f)}catch(a){throw new Error(`Replaceing auto migrated document "`+`${f[d]}" has failed: `+m.default.representObject(a))}console.info(`Auto migrating document "${f[d]}" `+'was successful.')}}if(c.database.createGenericFlatIndex&&c.database.model.autoMigrationPath){let a;try{a=(yield b.database.connection.getIndexes()).indexes}catch(a){throw a}for(const d in l)if(l.hasOwnProperty(d)&&new RegExp(c.database.model.property.name.typeRegularExpressionPattern.public).test(d))for(const e of y.default.determineGenericIndexablePropertyNames(c.database.model,l[d])){const c=`${d}-${e}-GenericIndex`;let f=-1,h=0;for(const b of a){if(b.name===c){f=h;break}h+=1}if(-1==f)try{yield b.database.connection.createIndex({index:{ddoc:c,fields:[g,e],name:c}})}catch(a){throw a}else a.slice(h,1)}for(const d of a)if(d.name.endsWith('-GenericIndex')){let a=!1;for(const b in l)if(d.name.startsWith(`${b}-`)){for(const e of y.default.determineGenericIndexablePropertyNames(c.database.model,l[b]))`${b}-${e}-GenericIndex`===d.name&&(a=!0);break}if(!a)try{yield b.database.connection.deleteIndex(d)}catch(a){throw a}}}return{name:'database',promise:a}})()}static preLoadService(a,b){return(0,j.default)(function*(){if(a.hasOwnProperty('database')||(a.database={}),!a.database.hasOwnProperty('connector')){const c=b.database.model.property.name.special.id,d=b.database.model.property.name.special.revision;a.database.connector=s.default;const e=a.database.connector.prototype.bulkDocs;a.database.connector.plugin({bulkDocs:(()=>{var a=(0,j.default)(function*(a,...f){!Array.isArray(a)&&'object'==typeof a&&null!==a&&c in a&&(a=[a]);let g=yield e.call(this,a,...f);const h=[],i=[];let j=0;for(const e of g){if('object'==typeof a[j]&&null!==a)if(d in a[j]&&'conflict'===e.name&&['latest','upsert'].includes(a[j][d]))i.push(e),h.push(j);else if(c in a[j]&&b.database.ignoreNoChangeError&&'name'in e&&'forbidden'===e.name&&'message'in e&&e.message.startsWith('NoChange:')){g[j]={id:a[j][c],ok:!0};try{g[j].rev=d in a[j]&&!['latest','upsert'].includes(a[j][d])?a[j][d]:(yield this.get(g[j].id))[d]}catch(a){throw a}}j+=1}if(i.length){a=i;const b=yield this.bulkDocs(a,...f);for(const a of b)g[h.shift()]=a}return g});return function(){return a.apply(this,arguments)}})()}),b.database.debug&&a.database.connector.debug.enable('*'),a.database.connector=a.database.connector.plugin(u.default)}if(!a.database.hasOwnProperty('server')){a.database.server={};for(const c of b.database.binary.locations){const d=q.default.resolve(c,b.database.binary.name);(yield m.default.isFile(d))&&(a.database.server.binaryFilePath=d)}if(!a.database.server.hasOwnProperty('binaryFilePath'))throw new Error('No binary file name "'+`${b.database.binary.name}" in one of the `+'following locations found: "'+`${b.database.binary.locations.join('", "')}`+'".')}return a})()}static shouldExit(a,b){return(0,j.default)(function*(){const c='log.txt';return(yield m.default.isFile(c))&&(yield new h.default(function(a,b){return o.default.unlink(c,function(c){return c?b(c):a()})})),a.database.connection.close(),a.database.server.process.kill('SIGINT'),yield m.default.checkUnreachability(m.default.stringFormat(b.database.url,''),!0),delete a.database,a})()}}b.Database=z,b.default=z},function(a){a.exports=require('babel-runtime/core-js/promise')},function(a){a.exports=require('child_process')},function(a){a.exports=require('fs')},function(a){a.exports=require('path')},function(a){a.exports=require('pouchdb')},function(a){a.exports=require('pouchdb-find')},function(a,b,c){'use strict';function d(a){return a&&a.__esModule?a:{default:a}}b.__esModule=!0,b.DatabaseHelper=void 0;var e=c(17),f=d(e),g=c(18),h=d(g),i=c(19),j=d(i),k=c(1),l=d(k),m=c(6),n=d(m);try{c(0)}catch(a){}class o{static authenticate(a,b,c={db:'dummy',name:'"unknown"',roles:[]},d={admins:{names:[],roles:[]},members:{names:[],roles:[]}},e,f,g,h=!1){if(!a.hasOwnProperty(g))return!0;const i={properties:{},read:['_admin','readonlyadmin'],write:['_admin']};a.hasOwnProperty(f)&&a[f].startsWith('_design/')&&i.read.push('readonlymember');let j=`Current user doesn't own any role`;const k=h?'read':'write';if(c){if('name'in c||(c.name='"unknown"'),e&&g&&a.hasOwnProperty(g)&&e.hasOwnProperty(a[g]))for(const b in i)i.hasOwnProperty(b)&&a.hasOwnProperty(g)&&(i[b]=Array.isArray(i[b])?i[b].concat(e[a[g]][b]):e[a[g]][b]);if(c.roles.length){const a=i[k];for(const b of c.roles)if(a.includes(b))return!0;j=`Current user "${c.name}" `+`owns the following roles: "`+`${c.roles.join('", "')}".`}else j=`Current user "${c.name}" `+`doesn't own any role`}throw{unauthorized:'Only users with a least on of these roles are allowed to '+`perform requested ${k} action: "`+`${i[k].join('", "')}". `+`${j}.`}}static validateDocumentUpdate(a,b,c={db:'dummy',name:'admin',roles:['_admin']},d={admins:{names:[],roles:[]},members:{names:[],roles:[]}},e,g,i=null){const k=new Date,m=Date.UTC(k.getUTCFullYear(),k.getUTCMonth(),k.getUTCDate(),k.getUTCHours(),k.getUTCMinutes(),k.getUTCSeconds(),k.getUTCMilliseconds())/1e3,o=g.property.name.special,p=o.id,q=o.revision;if(d.hasOwnProperty(g.property.name.validatedDocumentsCache)&&d[g.property.name.validatedDocumentsCache].has(`${a[p]}-${a[q]}`))return d[g.property.name.validatedDocumentsCache].delete(`${a[p]}-${a[q]}`),a;if(a.hasOwnProperty(q)&&['latest','upsert'].includes(a[q]))if(b&&b.hasOwnProperty(q))a[q]=b[q];else if('latest'===a[q])throw{forbidden:'Revision: No old document available to update.'};else delete a[q];let r=g.updateStrategy;a.hasOwnProperty(o.strategy)&&(r=a[o.strategy],delete a[o.strategy]);let s;if(i)s=i;else if(JSON&&JSON.hasOwnProperty('stringify'))s=(a)=>(0,n.default)(a,null,4);else throw new Error('Needed "serialize" function is not available.');const t=(a,b)=>{if(b){for(const c in a)if(a.hasOwnProperty(c)&&c.startsWith(b))return c;}else{const b=(0,l.default)(a);if(b.length)return b[0]}return null},u=(a,b)=>{if(a.hasOwnProperty(o.attachment)){const c=t(a[o.attachment],b);if(c)return a[o.attachment][c].hasOwnProperty('stub')&&a[o.attachment][c].stub||a[o.attachment][c].hasOwnProperty('data')&&![void 0,null].includes(a[o.attachment][c].data)}return!1},v=(a,b,f=[])=>{const i=f.length?` in ${f.join(' -> ')}`:'';let n=[];if(!a.hasOwnProperty(o.type))throw{forbidden:'Type: You have to specify a model type via '+`property "${o.type}"${i}.`};if(!(f.length||new RegExp(g.property.name.typeRegularExpressionPattern.public).test(a[o.type])))throw{forbidden:'TypeName: You have to specify a model type which matches "'+g.property.name.typeRegularExpressionPattern.public+'" as public type (given "'+a[o.type]+`")${i}.`};if(!e.hasOwnProperty(a[o.type]))throw{forbidden:'Model: Given model "'+a[o.type]+`" is not specified${i}.`};const w=a[o.type],x=e[w];let y=null;x.hasOwnProperty(o.additional)&&x[o.additional]&&(y=x[o.additional]);const z=(h,n,o,p,q=['constraintExpression','constraintExecution'])=>{for(const r of q)if(o[r]){let q;const y=(r.endsWith('Expression')?'return ':'')+o[r].evaluation,z={attachmentWithPrefixExists:u.bind(a,a),checkDocument:v,checkPropertyContent:A,code:y,getFilenameByPrefix:t,model:x,modelConfiguration:g,modelName:w,models:e,name:n,newDocument:a,newValue:h,now:k,nowUTCTimestamp:m,oldDocument:b,oldValue:p,parentNames:f,pathDescription:i,propertySpecification:o,securitySettings:d,serialize:s,userContext:c};try{q=new Function(...(0,l.default)(z),y)}catch(a){throw{forbidden:`Compilation: Hook "${r}" has invalid`+` code "${y}": "${s(a)}`+`"${i}.`}}let B=!1;try{B=q(...(0,j.default)(z))}catch(a){throw{forbidden:`Runtime: Hook "${r}" has throw an `+`error with code "${y}": "`+`${s(a)}"${i}.`}}if(!B)throw{forbidden:r.charAt(0).toUpperCase()+r.substring(1)+`: `+(o[r].description?new Function(...(0,l.default)(z),'return '+o[r].description)(...(0,j.default)(z)):`Property "${n}" should `+`satisfy constraint "${y}" (given "`+`${s(h)}")${i}.`)}}},A=(a,b,c,d=null)=>{let g=[];const j=Array.isArray(c.type)?c.type:[c.type];'object'==typeof a&&(0,h.default)(a)===Object.prototype&&!a.hasOwnProperty(o.type)&&1===j.length&&e.hasOwnProperty(j[0])&&(a[o.type]=j[0]);let k=!1;for(const l of j)if(e.hasOwnProperty(l)){if('object'==typeof a&&(0,h.default)(a)===Object.prototype&&a.hasOwnProperty(o.type)&&a[o.type]===l){const c=v(a,d,f.concat(b));if(c.changedPath.length&&(g=c.changedPath),a=c.newDocument,s(a)===s({}))return{newValue:null,changedPath:g};k=!0;break}else if(1===j.length)throw{forbidden:`NestedType: Under key "${b}" isn't `+`of type "${l}" (given "`+`${s(a)}" of type `+`${typeof a})${i}.`};}else if('DateTime'===l){const c=a;if(null!==a&&'number'!=typeof a&&(a=new Date(a),a=Date.UTC(a.getUTCFullYear(),a.getUTCMonth(),a.getUTCDate(),a.getUTCHours(),a.getUTCMinutes(),a.getUTCSeconds(),a.getUTCMilliseconds())/1e3),!('number'!=typeof a||isNaN(a))){k=!0;break}else if(1===j.length)throw{forbidden:`PropertyType: Property "${b}" `+`isn't of (valid) type "DateTime" (`+`given "`+s(c).replace(/^"/,'').replace(/"$/,'')+`" of type "`+`${typeof c}")`+`${i}.`}}else if(['boolean','integer','number','string'].includes(l)){if(!('number'==typeof a&&isNaN(a)||'integer'!==l&&typeof a!==l||'integer'===l&&parseInt(a)!==a)){k=!0;break}else if(1===j.length)throw{forbidden:`PropertyType: Property "${b}"`+` isn't of (valid) type "${l}" (`+`given "${s(a)}" of `+`type "${typeof a}")`+`${i}.`};}else if('string'==typeof l&&l.startsWith('foreignKey:')){const c=e[l.substring(11)][p].type;if(c===typeof a){k=!0;break}else if(1===j.length)throw{forbidden:`PropertyType: Foreign key property "`+`${b}" isn't of type "`+`${c}" (given "`+`${s(a)}" of type "`+`${typeof a}")${i}.`}}else if('any'===l||s(a)===s(l)){k=!0;break}else if(1===j.length)throw{forbidden:`PropertyType: Property "${b}" isn't `+`value "${l}" (given "`+s(a).replace(/^"/,'').replace(/"$/,'')+`" of type "${typeof a}")`+`${i}.`};if(!k)throw{forbidden:'PropertyType: None of the specified types "'+`${j.join('", "')}" for property "${b}" `+`matches value "`+s(a).replace(/^"/,'').replace(/"$/,'')+`${a}" of type "${typeof a}")`+`${i}.`};if('string'==typeof a){if(![void 0,null].includes(c.minimumLength)&&a.length<c.minimumLength)throw{forbidden:`MinimalLength: Property "${b}" must have`+' minimal length '+`${c.minimumLength} (`+`given ${a} with length `+`${a.length})${i}.`};if(![void 0,null].includes(c.maximumLength)&&a.length>c.maximumLength)throw{forbidden:`MaximalLength: Property "${b}" must have`+' maximal length '+`${c.maximumLength} (`+`given ${a} with length `+`${a.length})${i}.`}}if('number'==typeof a){if(![void 0,null].includes(c.minimum)&&a<c.minimum)throw{forbidden:`Minimum: Property "${b}" (type `+`${c.type}) must `+'satisfy a minimum of '+`${c.minimum} (`+`given ${a} with length `+`${a.length})${i}.`};if(![void 0,null].includes(c.maximum)&&a>c.maximum)throw{forbidden:`Maximum: Property "${b}" (type `+`${c.type}) must `+'satisfy a maximum of '+`${c.maximum} (`+`given ${a} with length `+`${a.length}${i}.`}}if(c.selection&&!c.selection.includes(a))throw{forbidden:`Selection: Property "${b}" (type `+`${c.type}) should be one of`+' "'+c.selection.join('", "')+`". But is "${a}"${i}.`};if(!([void 0,null].includes(c.regularExpressionPattern)||new RegExp(c.regularExpressionPattern).test(a)))throw{forbidden:`PatternMatch: Property "${b}" should match `+'regular expression pattern '+c.regularExpressionPattern+` (given "${a}")${i}.`};else if(![void 0,null].includes(c.invertedRegularExpressionPattern)&&new RegExp(c.invertedRegularExpressionPattern).test(a))throw{forbidden:`InvertedPatternMatch: Property "${b}" should`+' not match regular expression pattern '+c.invertedRegularExpressionPattern+` (given "${a}")${i}.`};return z(a,b,c,d),s(a)!==s(d)&&(g=f.concat(b,'value updated')),{newValue:a,changedPath:g}},B=(a,b,f,h)=>{if(!f)for(const n of['onCreateExpression','onCreateExecution'])if(a[n]){let o;const p={attachmentWithPrefixExists:u.bind(b,b),checkDocument:v,checkPropertyContent:A,getFilenameByPrefix:t,model:x,modelConfiguration:g,modelName:w,models:e,name:h,newDocument:b,now:k,nowUTCTimestamp:m,oldDocument:f,propertySpecification:a,securitySettings:d,serialize:s,userContext:c};try{o=new Function(...(0,l.default)(p),(n.endsWith('Expression')?'return ':'')+a[n])}catch(b){throw{forbidden:`Compilation: Hook "${n}" has `+'invalid code "'+`${a[n]}" for`+` property "${h}": `+s(b)+`${i}.`}}let q;try{q=o(...(0,j.default)(p))}catch(b){throw{forbidden:`Runtime: Hook "${n}" has throw `+'an error with code "'+`${a[n]}" `+`for property "${h}": `+s(b)+`${i}.`}}[void 0,null].includes(q)||(b[h]=q)}},C=(a,b,f,h)=>{if(b.hasOwnProperty(h)){a.trim&&'string'==typeof b[h]&&(b[h]=b[h].trim()),a.emptyEqualsToNull&&(''===b[h]||Array.isArray(b[h])&&0===b[h].length||'object'==typeof b[h]&&null!==b[h]&&0===(0,l.default)(b).length)&&(b[h]=null);for(const n of['onUpdateExpression','onUpdateExecution'])if(a[n]){let o;const p={attachmentWithPrefixExists:u.bind(b,b),checkDocument:v,checkPropertyContent:A,getFilenameByPrefix:t,model:x,modelConfiguration:g,modelName:w,models:e,name:h,newDocument:b,now:k,nowUTCTimestamp:m,oldDocument:f,propertySpecification:a,securitySettings:d,serialize:s,userContext:c};try{o=new Function(...(0,l.default)(p),(n.endsWith('Expression')?'return ':'')+a[n])}catch(b){throw{forbidden:`Compilation: Hook "${n}" has invalid`+` code "${a[n]}" `+`for property "${h}": `+`${s(b)}${i}.`}}try{b[h]=o(...(0,j.default)(p))}catch(b){throw{forbidden:`Runtime: Hook "${n}" has throw an `+'error with code "'+`${a[n]}" for `+`property "${h}": ${s(b)}`+`${i}.`}}}}},D=(0,l.default)(x).filter((a)=>![o.additional,o.allowedRole,o.constraint.execution,o.constraint.expression,o.extend,o.maximumAggregatedSize,o.minimumAggregatedSize].includes(a));for(const c of D.concat(y?(0,l.default)(a).filter((a)=>!D.includes(a)):[]))if(o.attachment===c)for(const d in x[c]){a.hasOwnProperty(c)&&null!==a[c]||(a[c]={}),b&&!b.hasOwnProperty(c)&&(b[c]={});const e=(0,l.default)(a[c]).filter((b)=>null!==a[c][b].data&&new RegExp(d).test(b));let g=[];b&&(g=(0,l.default)(b[c]).filter((e)=>!(a.hasOwnProperty(c)&&a[c].hasOwnProperty(e)&&a[c][e].hasOwnProperty('data')&&null===a[c][e].data)&&b[c][e]&&null!==b[c][e].data&&new RegExp(d).test(e)));for(const f of e)B(x[c][d],a[c],b&&b[c]?b[c]:null,f);for(const f of e)C(x[c][d],a[c],b&&b[c]?b[c]:null,f);if([void 0,null].includes(x[c][d].default)){if(!(x[c][d].nullable||0<e.length||0<g.length))throw{forbidden:'AttachmentMissing: Missing '+`attachment for type "${d}"`+`${i}.`};if('fillUp'===r&&0===e.length&&0<g.length)for(const d of g)null===a[c][d]?n=f.concat(c,d,'file removed'):a[c][d]=b[c][d]}else if(0===e.length)if(0===g.length)for(const b in x[c][d].default)x[c][d].default.hasOwnProperty(b)&&(a[c][b]=x[c][d].default[b],n=f.concat(c,d,'add default file'));else if('fillUp'===r)for(const d of g)a[c][d]=b[c][d]}else{const d=D.includes(c)?x[c]:y;if(B(d,a,b,c),C(d,a,b,c),[void 0,null].includes(d.default)){if(!(d.nullable||a.hasOwnProperty(c)||b&&b.hasOwnProperty(c)&&r))throw{forbidden:'MissingProperty: Missing property "'+`${c}"${i}.`};!a.hasOwnProperty(c)&&b&&b.hasOwnProperty(c)&&('fillUp'===r?a[c]=b[c]:!r&&(n=f.concat(c,'property removed')))}else a.hasOwnProperty(c)&&null!==a[c]||(b&&b.hasOwnProperty(c)?'fillUp'===r?a[c]=b[c]:'migrate'===r&&(a[c]=d.default,n=f.concat(c,'migrate default value')):(a[c]=d.default,n=n.concat(c,'add default value')))}if(b&&'incremental'===r)for(const c in a)if(a.hasOwnProperty(c)&&b.hasOwnProperty(c)&&!g.property.name.reserved.concat(p,q,o.conflict,o.deleted,o.deletedConflict,o.localSequence,o.revisions,o.revisionsInformation,o.type).includes(c)&&(b[c]===a[c]||s(b[c])===s(a[c]))){delete a[c];continue}for(const c in a)if(a.hasOwnProperty(c)&&!g.property.name.reserved.concat(q,o.conflict,o.deleted,o.deletedConflict,o.localSequence,o.revisions,o.revisionsInformation,o.strategy).includes(c)){let d;if(x.hasOwnProperty(c))d=x[c];else if(y)d=y;else if('migrate'===r){delete a[c],n=f.concat(c,'migrate removed property');continue}else throw{forbidden:'Property: Given property "'+`${c}" isn't specified in `+`model "${w}"${i}.`};if(!d)continue;const j=(a,b,c,d)=>{if(!a.writable)if(c){if(c.hasOwnProperty(d)&&s(b[d])===s(c[d]))return d!==p&&'incremental'===r&&delete b[d],!0;throw{forbidden:'Readonly: Property "'+`${d}" is not writable (old `+`document "`+`${s(c)}")`+`${i}.`}}else throw{forbidden:`Readonly: Property "${d}"`+` is not writable${i}.`};if(!a.mutable&&c&&c.hasOwnProperty(d)){if(s(b[d])===s(c[d]))return'incremental'!==r||g.property.name.reserved.concat(o.deleted,p,q).includes(d)||delete b[d],!0;throw{forbidden:`Immutable: Property "${d}`+'" is not writable (old document "'+`${s(c)}")`+`${i}.`}}if(null===b[d]){if(a.nullable)return delete b[d],c&&c.hasOwnProperty(d)&&(n=f.concat(d,'delete property')),!0;throw{forbidden:`NotNull: Property "${d}" `+'should not by "null"'+`${i}.`}}return!1};if(o.attachment===c){for(const d in a[c])if(a[c].hasOwnProperty(d))for(const e in x[c])if(x[c].hasOwnProperty(e)&&new RegExp(e).test(d)){j(x[c][e],a,b,d);break}continue}else if(j(d,a,b,c))continue;if('string'==typeof d.type&&d.type.endsWith('[]')||Array.isArray(d.type)&&d.type.length&&Array.isArray(d.type[0])){if(!Array.isArray(a[c]))throw{forbidden:`PropertyType: Property "${c}" isn't `+`of type "array -> `+`${d.type}" (given "`+`${s(a[c])}")`+`${i}.`};else if(![void 0,null].includes(d.minimumNumber)&&a[c].length<d.minimumNumber)throw{forbidden:`MinimumArrayLength: Property "${c}" `+` (array of length `+`${a[c].length}) doesn't `+`fullfill minimum array length of `+d.minimumNumber+`${i}.`};else if(![void 0,null].includes(d.maximumNumber)&&d.maximumNumber<a[c].length)throw{forbidden:`MaximumArrayLength: Property "${c}" `+`(array of length `+`${a[c].length}) doesn't `+`fullfill maximum array length of `+d.maximumNumber+`${i}.`};z(a[c],c,d,b&&b.hasOwnProperty(c)&&b[c]||void 0,['arrayConstraintExpression','arrayConstraintExecution']);const g={};for(const a in d)d.hasOwnProperty(a)&&(g[a]='type'===a?Array.isArray(d[a])?d[a][0]:[d[a].substring(0,d.type.length-2)]:d[a]);if(1===typeof g.type.length&&e.hasOwnProperty(g.type[0]))for(const b of a[c].slice())'object'!=typeof b||(0,h.default)(b)!==Object.prototype||b.hasOwnProperty(o.type)||(b[o.type]=g.type[0]);let j=0;for(const b of a[c].slice())a[c][j]=A(b,`${j+1}. value in ${c}`,g).newValue,null===b&&a[c].splice(j,1),j+=1;b&&b.hasOwnProperty(c)&&Array.isArray(b[c])&&b[c].length===a[c].length&&s(b[c])===s(a[c])||(n=f.concat(c,'array updated'))}else{const e=b&&b.hasOwnProperty(c)?b[c]:null,g=A(a[c],c,d,e);a[c]=g.newValue,g.changedPath.length&&(n=g.changedPath),null===a[c]&&(null!==e&&(n=f.concat(c,'property removed')),delete a[c])}}for(let h in o.constraint)if(o.constraint.hasOwnProperty(h)&&(h=o.constraint[h])&&x.hasOwnProperty(h)&&Array.isArray(x[h])&&x[h].length)for(const n of x[h]){let p;const q=(h===o.constraint.expression?'return ':'')+n.evaluation,r={attachmentWithPrefixExists:u.bind(a,a),checkDocument:v,checkPropertyContent:A,code:q,getFilenameByPrefix:t,model:x,modelConfiguration:g,modelName:w,models:e,newDocument:a,now:k,nowUTCTimestamp:m,oldDocument:b,parentNames:f,pathDescription:i,securitySettings:d,serialize:s,userContext:c};try{p=new Function(...(0,l.default)(r),q)}catch(a){throw{forbidden:`Compilation: Hook "${h}" has `+`invalid code "${q}": "`+s(a)+`"${i}.`}}let y=!1;try{y=p(...(0,j.default)(r))}catch(a){throw{forbidden:`Runtime: Hook "${h}" has `+`thrown an error with code "${q}": `+`${s(a)}${i}.`}}if(!y){const b=h.replace(/^[^a-zA-Z]+/,'');throw{forbidden:b.charAt(0).toUpperCase()+`${b.substring(1)}: `+(n.description?new Function(...(0,l.default)(r),`return ${n.description}`)(...(0,j.default)(r)):`Model "${w}" should satisfy `+`constraint "${q}" (given "`+`${s(a)}")`+`${i}.`)}}}if(a.hasOwnProperty(o.attachment)){const c=a[o.attachment];if('object'!=typeof c||(0,h.default)(c)!==Object.prototype)throw{forbidden:'AttachmentType: given attachment has '+`invalid type${i}.`};let d=null;if(b&&b.hasOwnProperty(o.attachment)&&(d=b[o.attachment],null!==d&&'object'==typeof d))for(const a in d)d.hasOwnProperty(a)&&(c.hasOwnProperty(a)?null===c[a]||null===c[a].data||c[a].content_type===d[a].content_type&&c[a].data===d[a].data?((null===c[a]||null===c[a].data)&&(n=f.concat(o.attachment,a,'attachment removed')),'incremental'===r&&delete c[a]):n=f.concat(o.attachment,a,'attachment updated'):'fillUp'===r?c[a]=d[a]:r||(n=f.concat(o.attachment,a,'attachment removed')));for(const a in c)c.hasOwnProperty(a)&&([void 0,null].includes(c[a])||null===c[a].data?delete c[a]:d&&d.hasOwnProperty(a)&&c[a].content_type===d[a].content_type&&c[a].data===d[a].data||(n=f.concat(o.attachment,a,'attachment updated')));0===(0,l.default)(c).length&&delete a[o.attachment];const e={};for(const a in x[o.attachment])x[o.attachment].hasOwnProperty(a)&&(e[a]=[]);for(const a in c)if(c.hasOwnProperty(a)){let b=!1;for(const c in x[o.attachment])if(new RegExp(c).test(a)){e[c].push(a),b=!0;break}if(!b)throw{forbidden:'AttachmentTypeMatch: None of the specified attachment types ("'+(0,l.default)(x[o.attachment]).join('", "')+'") matches given one '+`("${a}")${i}.`}}let g=0;for(const a in e){if(!e.hasOwnProperty(a))continue;const b=e[a].length;if(null!==x[o.attachment][a].maximumNumber&&b>x[o.attachment][a].maximumNumber)throw{forbidden:'AttachmentMaximum: given number of '+`attachments (${b}) `+`doesn't satisfy specified maximum of `+x[o.attachment][a].maximumNumber+` from type "${a}"${i}.`};if(!(x[o.attachment][a].nullable&&0===b)&&b<x[o.attachment][a].minimumNumber)throw{forbidden:'AttachmentMinimum: given number of '+`attachments (${b}) `+`doesn't satisfy specified minimum of `+x[o.attachment][a].minimumNumber+` from type "${a}"${i}.`};let d=0;for(const b of e[a]){if(!([null,void 0].includes(x[o.attachment][a].regularExpressionPattern)||new RegExp(x[o.attachment][a].regularExpressionPattern).test(b)))throw{forbidden:'AttachmentName: given attachment name "'+`${b}" doesn't satisfy specified `+'regular expression pattern "'+x[o.attachment][a].regularExpressionPattern+`" from type "${a}"${i}.`};else if(![null,void 0].includes(x[o.attachment][a].invertedRegularExpressionPattern)&&new RegExp(x[o.attachment][a].invertedRegularExpressionPattern).test(b))throw{forbidden:'InvertedAttachmentName: given '+`attachment name "${b}" doesn't `+'satisfy specified regular expression pattern "'+x[o.attachment][a].invertedRegularExpressionPattern+`" from type "${a}"${i}.`};else if(!([null,void 0].includes(x[o.attachment][a].contentTypeRegularExpressionPattern)||c[b].hasOwnProperty('content_type')&&c[b].content_type&&new RegExp(x[o.attachment][a].contentTypeRegularExpressionPattern).test(c[b].content_type)))throw{forbidden:'AttachmentContentType: given attachment content type "'+c[b].content_type+`" doesn't satisfy specified regular`+' expression pattern "'+x[o.attachment][a].contentTypeRegularExpressionPattern+`" from type "${a}"${i}.`};const e=x[o.attachment][a].invertedContentTypeRegularExpressionPattern;if(!([null,void 0].includes(e)||c[b].hasOwnProperty('content_type')&&c[b].content_type&&!new RegExp(e).test(c[b].content_type)))throw{forbidden:'InvertedAttachmentContentType: given attachment content type "'+c[b].content_type+`" doesn't satisfy specified regular`+` expression pattern "${e}" `+`from type "${a}"${i}.`};let f=0;if('length'in c[b]?f=c[b].length:'data'in c[b]&&(Buffer&&'byteLength'in Buffer?f=Buffer.byteLength(c[b].data,'base64'):f=c.data.length),![null,void 0].includes(x[o.attachment][a].minimumSize)&&x[o.attachment][a].minimumSize>f)throw{forbidden:'AttachmentMinimumSize: given attachment'+` size ${f} byte doesn't satisfy `+'specified minimum  of '+x[o.attachment][a].minimumSize+` byte ${i}.`};else if(![null,void 0].includes(x[o.attachment][a].maximumSize)&&x[o.attachment][a].maximumSize<f)throw{forbidden:'AttachmentMaximumSize: given attachment'+` size ${f} byte doesn't satisfy `+'specified maximum of '+x[o.attachment][a].maximumSize+` byte ${i}.`};d+=f}if(![null,void 0].includes(x[o.attachment][a].minimumAggregatedSize)&&x[o.attachment][a].minimumAggregatedSize>d)throw{forbidden:'AttachmentAggregatedMinimumSize: given  aggregated size of attachments from type "'+`${a}" ${d} byte doesn't `+'satisfy specified minimum of '+x[o.attachment][a].minimumAggregatedSize+` byte ${i}.`};else if(![null,void 0].includes(x[o.attachment][a].maximumAggregatedSize)&&x[o.attachment][a].maximumAggregatedSize<d)throw{forbidden:'AttachmentAggregatedMaximumSize: given  aggregated size of attachments from type "'+`${a}" ${d} byte doesn't `+'satisfy specified maximum of '+x[o.attachment][a].maximumAggregatedSize+` byte ${i}.`};g+=d}if(x.hasOwnProperty(o.minimumAggregatedSize)&&![null,void 0].includes(x[o.minimumAggregatedSize])&&x[o.minimumAggregatedSize]>g)throw{forbidden:'AggregatedMinimumSize: given aggregated size '+`${g} byte doesn't satisfy `+'specified minimum of '+x[o.minimumAggregatedSize]+` byte ${i}.`};else if(x.hasOwnProperty(o.maximumAggregatedSize)&&![null,void 0].includes(x[o.maximumAggregatedSize])&&x[o.maximumAggregatedSize]<g)throw{forbidden:'AggregatedMaximumSize: given aggregated size '+`${g} byte doesn't satisfy `+'specified maximum of '+x[o.maximumAggregatedSize]+` byte ${i}.`}}if(b&&b.hasOwnProperty(o.attachment)&&0===(0,l.default)(b[o.attachment]).length&&delete b[o.attachment],0===n.length&&b&&'migrate'===r)for(const c in b)b.hasOwnProperty(c)&&!a.hasOwnProperty(c)&&(n=f.concat(c,'migrate removed property'));return{changedPath:n,newDocument:a}},w=v(a,b);if(w.newDocument._deleted&&!b||!(w.newDocument._deleted&&b&&w.newDocument._deleted!==b._deleted||w.changedPath.length))throw{forbidden:'NoChange: No new data given. new document: '+`${s(a)}; old document: `+`${s(b)}.`};return d.hasOwnProperty('checkedDocuments')?d[g.property.name.validatedDocumentsCache].add(`${a[p]}-${a[q]}`):d[g.property.name.validatedDocumentsCache]=new f.default([`${a[p]}-${a[q]}`]),w.newDocument}}b.DatabaseHelper=o,b.default=o},function(a){a.exports=require('babel-runtime/core-js/set')},function(a){a.exports=require('babel-runtime/core-js/object/get-prototype-of')},function(a){a.exports=require('babel-runtime/core-js/object/values')}]);